# Claude Full Review Workflow (reusable)
# Extracted from code-review.yaml full-review path.
# Handles:
#   1. pull_request events (opened, reopened, ready_for_review, synchronize, review_requested)
#   2. /review slash command on PR issue_comment events
# Includes post-review ready automation as an internal second job.

---
name: Claude Full Review

on:
  workflow_call:
    secrets:
      CLAUDE_CODE_OAUTH_TOKEN:
        required: true
      CLAUDE_REVIEW_GH_TOKEN:
        required: true
    outputs:
      ready:
        description: "Parsed READY_FOR_REVIEW value (true/false)"
        value: ${{ jobs.review.outputs.ready }}
      found:
        description: "Whether a structured marker or fallback review state was found"
        value: ${{ jobs.review.outputs.found }}
      pr_number:
        description: "PR number processed by this run"
        value: ${{ jobs.review.outputs.pr_number }}
      head_sha:
        description: "Current PR head SHA"
        value: ${{ jobs.review.outputs.head_sha }}

permissions:
  contents: read
  issues: write
  pull-requests: write
  actions: read

jobs:
  review:
    runs-on: ubicloud-standard-2
    timeout-minutes: 30
    env:
      # Force AI review actions to use the FINN DevOps PAT so downstream workflows are triggered
      GITHUB_TOKEN: ${{ secrets.CLAUDE_REVIEW_GH_TOKEN }}
      GH_TOKEN: ${{ secrets.CLAUDE_REVIEW_GH_TOKEN }}
    outputs:
      ready: ${{ steps.set-outputs.outputs.ready }}
      found: ${{ steps.set-outputs.outputs.found }}
      pr_number: ${{ steps.set-outputs.outputs.pr_number }}
      head_sha: ${{ steps.set-outputs.outputs.head_sha }}
    if: |
      (
        github.event_name == 'pull_request' &&
        (
          github.event.action == 'opened' ||
          github.event.action == 'reopened' ||
          github.event.action == 'ready_for_review' ||
          github.event.action == 'synchronize' ||
          github.event.action == 'review_requested'
        )
      ) ||
      (
        github.event_name == 'issue_comment' &&
        startsWith(github.event.comment.body, '/review')
      )
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.CLAUDE_REVIEW_GH_TOKEN }}

      - name: Extract PR number
        id: extract-pr
        shell: bash
        run: |
          set -euo pipefail
          echo "Event: ${{ github.event_name }}"

          if [[ "${{ github.event_name }}" == "pull_request" ]]; then
            PR_NUMBER="${{ github.event.pull_request.number }}"
            echo "üìã PR number from pull_request event: $PR_NUMBER"
          elif [[ "${{ github.event_name }}" == "issue_comment" ]]; then
            # For issue_comment events on PRs, PR number is issue.number
            if [[ "${{ github.event.issue.pull_request }}" != "" ]]; then
              PR_NUMBER="${{ github.event.issue.number }}"
              echo "üí¨ PR number from issue_comment event: $PR_NUMBER"
            else
              echo "‚ö†Ô∏è Issue comment is not on a PR, skipping"
              echo "::notice::Skipping: Comment is on an issue, not a pull request"
              echo "has_pr=false" >> "$GITHUB_OUTPUT"
              exit 0
            fi
          else
            echo "‚ö†Ô∏è Could not determine PR number for event: ${{ github.event_name }}"
            echo "::error::Unsupported event type: ${{ github.event_name }}"
            exit 1
          fi

          echo "pr_number=$PR_NUMBER" >> "$GITHUB_OUTPUT"
          echo "has_pr=true" >> "$GITHUB_OUTPUT"
          echo "‚úÖ Using PR number: $PR_NUMBER"

      - name: Fetch PR head SHA
        id: fetch-pr
        if: steps.extract-pr.outputs.has_pr == 'true'
        shell: bash
        run: |
          set -euo pipefail

          PR_NUMBER="${{ steps.extract-pr.outputs.pr_number }}"
          HEAD_SHA=$(gh api repos/${{ github.repository }}/pulls/${PR_NUMBER} --jq '.head.sha')

          echo "head_sha=$HEAD_SHA" >> "$GITHUB_OUTPUT"
          echo "‚úÖ PR #${PR_NUMBER} head SHA: ${HEAD_SHA}"

      - name: Extract full-review context
        id: extract-context
        if: steps.extract-pr.outputs.has_pr == 'true'
        shell: bash
        env:
          EVENT_NAME: ${{ github.event_name }}
          EVENT_ACTION: ${{ github.event.action }}
          COMMENT_BODY_ISSUE: ${{ github.event_name == 'issue_comment' && github.event.comment.body || '' }}
          COMMENT_AUTHOR_ISSUE: ${{ github.event_name == 'issue_comment' && github.event.comment.user.login || '' }}
          PR_AUTHOR: ${{ github.event.pull_request.user.login || '' }}
        run: |
          set -euo pipefail

          CONTEXT_TYPE=""
          COMMENT_AUTHOR=""
          COMMENT_BODY=""
          SLASH_ARGS=""
          TRIGGER_DESC=""

          if [[ "$EVENT_NAME" == "issue_comment" ]]; then
            CONTEXT_TYPE="slash_review"
            COMMENT_AUTHOR="$COMMENT_AUTHOR_ISSUE"
            COMMENT_BODY="$COMMENT_BODY_ISSUE"

            # Robust /review parsing (supports optional args, including multiline)
            if [[ "$COMMENT_BODY" =~ ^/review([[:space:]]|$) ]]; then
              SLASH_ARGS=$(printf '%s' "$COMMENT_BODY" | sed -E '1s#^/review[[:space:]]*##')
              TRIGGER_DESC="/review slash command"
            else
              echo "::notice::Comment did not match /review command; skipping"
              echo "has_review_trigger=false" >> "$GITHUB_OUTPUT"
              exit 0
            fi
          else
            CONTEXT_TYPE="pr_event"
            COMMENT_AUTHOR="$PR_AUTHOR"
            COMMENT_BODY="PR event: ${EVENT_ACTION}"
            SLASH_ARGS=""
            TRIGGER_DESC="pull_request event (${EVENT_ACTION})"
          fi

          echo "context_type=$CONTEXT_TYPE" >> "$GITHUB_OUTPUT"
          echo "comment_author=$COMMENT_AUTHOR" >> "$GITHUB_OUTPUT"
          echo "trigger_desc=$TRIGGER_DESC" >> "$GITHUB_OUTPUT"
          echo "has_review_trigger=true" >> "$GITHUB_OUTPUT"

          echo "comment_body<<EOF" >> "$GITHUB_OUTPUT"
          echo "$COMMENT_BODY" >> "$GITHUB_OUTPUT"
          echo "EOF" >> "$GITHUB_OUTPUT"

          echo "slash_args<<EOF" >> "$GITHUB_OUTPUT"
          echo "$SLASH_ARGS" >> "$GITHUB_OUTPUT"
          echo "EOF" >> "$GITHUB_OUTPUT"

          echo "‚úÖ Extracted full-review context: ${CONTEXT_TYPE}"

      - name: Define review instructions
        id: review-instructions
        if: |
          steps.extract-pr.outputs.has_pr == 'true' &&
          steps.extract-context.outputs.has_review_trigger == 'true'
        shell: bash
        run: |
          REVIEW_INSTRUCTIONS="Perform a comprehensive code review with the following focus areas:

            1. **Code Quality**
               - Clean code principles and best practices
               - Proper error handling and edge cases
               - Code readability and maintainability

            2. **Security**
               - Check for potential security vulnerabilities
               - Validate input sanitization
               - Review authentication/authorization logic

            3. **Performance**
               - Identify potential performance bottlenecks
               - Review database queries for efficiency
               - Check for memory leaks or resource issues

            4. **Testing**
               - Verify adequate test coverage
               - Review test quality and edge cases
               - Check for missing test scenarios

            5. **Documentation**
               - Ensure code is properly documented
               - Verify README updates for new features
               - Check API documentation accuracy

            ## Direct Fixes (MANDATORY)
            - Primary objective: get this PR to merge-ready in this run.
            - For every blocking issue you find, you MUST implement the fix directly on this PR branch and push commit(s).
            - Iterate review -> fix -> verify until no blocking issues remain.
            - Do NOT delegate fixes to Copilot or ask another agent to implement them.
            - You MUST resolve ALL review threads before approving. See the Review Thread Resolution section below.
            - For each thread: implement valid suggestions, dismiss false positives with rationale, then resolve.
            - You may use REQUEST_CHANGES only when hard-blocked by an external constraint you cannot resolve in-workflow.
              Hard-block examples:
              - no permission/policy to push to the PR branch
              - unresolved merge conflict/rebase that cannot be completed in this workflow
              - required secret or external system unavailable
              - missing product/owner decision required to proceed
            - When hard-blocked, post one explicit BLOCKED: summary comment with the exact blocker and exact next action.

            Use inline comments ONLY for issues that need to be fixed or changed.
            Do NOT leave inline comments for praise or positive observations.
            Post a final summary review using 'gh pr comment'.

            ## Approval Decision

            After completing your review, you MUST make an approval decision:

            **APPROVE the PR** if ALL of these conditions are met:
            - No security vulnerabilities found
            - No critical bugs or logic errors
            - Code follows project conventions
            - Tests pass (if applicable)

            To approve, run: gh pr review --approve --body 'LGTM - Code review passed. [brief summary of what was reviewed]'

            **REQUEST CHANGES** only if hard-blocked after attempting direct fixes:
            - You cannot push required changes from this workflow
            - You cannot safely resolve merge conflicts/rebase in this workflow
            - A required external dependency is unavailable
            - Human product/owner decision is required before implementation

            To request changes, run:
            gh pr review --request-changes --body 'BLOCKED: [exact blocker]. Next action: [specific next step].'

            IMPORTANT: Always make an explicit approval decision. Do not leave the PR without approving or requesting changes.

            ## Review Thread Resolution (MANDATORY ‚Äî zero unresolved threads before approve)
            Before finalizing, you MUST inspect ALL open review threads on this PR and resolve every single one.
            Use gh api graphql with the resolveReviewThread mutation to resolve threads programmatically.

            For each unresolved thread, apply ONE of these actions:
            1. **Valid suggestion** ‚Üí Implement the fix, push a commit, reply confirming the fix, then RESOLVE the thread.
            2. **False positive / not applicable** ‚Üí Reply explaining WHY it's incorrect or not relevant, then RESOLVE the thread.
            3. **Already addressed** ‚Üí Reply noting where/how it was addressed, then RESOLVE the thread.
            4. **Intentional design choice** ‚Üí Reply with the rationale, then RESOLVE the thread.

            Escape hatch (rare ‚Äî use sparingly):
            5. **Genuinely blocked** (needs human product decision, external dependency, or repo permission you lack) ‚Üí
               Reply with BLOCKED: [exact reason] in the thread. Do NOT resolve. Do NOT set READY_FOR_REVIEW=true.

            The rule is simple: **zero unresolved threads = can approve. Any unresolved thread = cannot approve.**
            The post-review automation will hard-fail if READY_FOR_REVIEW=true but unresolved threads remain.

            ## Structured Decision Marker (required)
            At the end of each full review, post EXACTLY one PR comment containing this exact marker block:
            <!-- CLAUDE_READY_DECISION -->
            READY_FOR_REVIEW=true|false
            <!-- /CLAUDE_READY_DECISION -->

            Set READY_FOR_REVIEW=true only when your final review decision is APPROVE.
            Set READY_FOR_REVIEW=false for request-changes outcomes."

          echo "instructions<<EOF" >> "$GITHUB_OUTPUT"
          echo "$REVIEW_INSTRUCTIONS" >> "$GITHUB_OUTPUT"
          echo "EOF" >> "$GITHUB_OUTPUT"

          echo "‚úÖ Review instructions defined"

      - name: Craft full-review prompt
        id: craft-prompt
        if: |
          steps.extract-pr.outputs.has_pr == 'true' &&
          steps.extract-context.outputs.has_review_trigger == 'true'
        shell: bash
        run: |
          set -euo pipefail

          # decision_required=true always in this reusable full-review workflow
          DECISION_REQUIRED="true"

          REVIEW_INSTRUCTIONS=$(cat <<'REVIEW_EOF'
          ${{ steps.review-instructions.outputs.instructions }}
          REVIEW_EOF
          )

          BASE_CONTEXT="REPO: ${{ github.repository }}
          PR NUMBER: ${{ steps.extract-pr.outputs.pr_number }}

          ## Trigger Context
          - **Type**: ${{ steps.extract-context.outputs.context_type }}
          - **Trigger**: ${{ steps.extract-context.outputs.trigger_desc }}
          - **Author**: @${{ steps.extract-context.outputs.comment_author }}"

          if [[ "${{ steps.extract-context.outputs.context_type }}" == "slash_review" ]]; then
            FULL_PROMPT="${BASE_CONTEXT}

          ## Slash Command
          The user triggered /review on this PR.
          Treat this as an explicit request for a full review.

          Additional user instructions from /review (if any):
          ${{ steps.extract-context.outputs.slash_args }}

          ${REVIEW_INSTRUCTIONS}

          IMPORTANT: Post your final summary as a PR comment with:
          gh pr comment --body 'Your response here'"
          else
            FULL_PROMPT="${BASE_CONTEXT}

          This PR event was triggered by action: ${{ github.event.action }}.
          ${REVIEW_INSTRUCTIONS}"
          fi

          echo "prompt<<EOF" >> "$GITHUB_OUTPUT"
          echo "$FULL_PROMPT" >> "$GITHUB_OUTPUT"
          echo "EOF" >> "$GITHUB_OUTPUT"
          echo "decision_required=$DECISION_REQUIRED" >> "$GITHUB_OUTPUT"

          echo "‚úÖ Crafted full-review prompt"

      - name: Check track_progress support
        id: check-track-progress
        if: |
          steps.extract-pr.outputs.has_pr == 'true' &&
          steps.extract-context.outputs.has_review_trigger == 'true'
        shell: bash
        run: |
          set -euo pipefail
          echo "Event: ${{ github.event_name }}, Action: ${{ github.event.action }}"

          case "${{ github.event_name }}" in
            pull_request)
              case "${{ github.event.action }}" in
                ready_for_review)
                  echo "track_progress=true" >> "$GITHUB_OUTPUT"
                  echo "‚úÖ track_progress supported for pull_request/${{ github.event.action }}"
                  ;;
                *)
                  echo "track_progress=false" >> "$GITHUB_OUTPUT"
                  echo "‚ö†Ô∏è track_progress not supported for pull_request/${{ github.event.action }}"
                  ;;
              esac
              ;;
            *)
              echo "track_progress=false" >> "$GITHUB_OUTPUT"
              echo "‚ö†Ô∏è track_progress not supported for ${{ github.event_name }}/${{ github.event.action }}"
              ;;
          esac

      - name: Capture review start timestamp
        id: review-started-at
        if: |
          steps.extract-pr.outputs.has_pr == 'true' &&
          steps.extract-context.outputs.has_review_trigger == 'true'
        shell: bash
        run: |
          set -euo pipefail
          echo "started_at=$(date -u +%Y-%m-%dT%H:%M:%SZ)" >> "$GITHUB_OUTPUT"

      - name: Run Claude full review
        uses: anthropics/claude-code-action@v1
        if: |
          steps.extract-pr.outputs.has_pr == 'true' &&
          steps.extract-context.outputs.has_review_trigger == 'true'
        with:
          claude_code_oauth_token: ${{ secrets.CLAUDE_CODE_OAUTH_TOKEN }}
          github_token: ${{ secrets.CLAUDE_REVIEW_GH_TOKEN }}
          track_progress: ${{ steps.check-track-progress.outputs.track_progress }}
          claude_args: |
            --model opus
            --allowedTools "mcp__github__add_comment_to_pending_review,
            mcp__github__add_pull_request_review_comment,
            mcp__github__create_issue_comment,
            mcp__github__create_pending_pull_request_review,
            mcp__github__get_file_contents,
            mcp__github__get_pull_request_diff,
            mcp__github__submit_pending_pull_request_review,
            mcp__github_ci__get_ci_status,
            mcp__github_ci__get_workflow_run_details,
            mcp__github_ci__download_job_log,
            mcp__github_comment__update_claude_comment,
            mcp__github_inline_comment__create_inline_comment,
            mcp__github_pulls__get_pull_request,
            mcp__github_pulls__list_pull_request_files,
            mcp__github_pulls__get_pull_request_diff,
            Bash,Read,Grep,Glob,WebFetch,WebSearch,TodoWrite"
          prompt: ${{ steps.craft-prompt.outputs.prompt }}

      - name: Parse structured ready decision
        id: parse-ready-decision
        if: |
          steps.extract-pr.outputs.has_pr == 'true' &&
          steps.extract-context.outputs.has_review_trigger == 'true' &&
          steps.craft-prompt.outputs.decision_required == 'true'
        shell: bash
        run: |
          set -euo pipefail

          PR_NUMBER="${{ steps.extract-pr.outputs.pr_number }}"
          RUN_STARTED_AT="${{ steps.review-started-at.outputs.started_at }}"
          AUTOMATION_LOGIN=$(gh api user --jq '.login')

          COMMENTS_JSON=$(gh api repos/${{ github.repository }}/issues/${PR_NUMBER}/comments --paginate)
          DECISION_BODY=$(printf '%s' "$COMMENTS_JSON" | jq -r --arg run_started_at "$RUN_STARTED_AT" --arg automation_login "$AUTOMATION_LOGIN" '
            [
              .[]
              | select(.user.login == $automation_login)
              | select(.created_at >= $run_started_at)
              | select(.body | contains("<!-- CLAUDE_READY_DECISION -->"))
            ]
            | sort_by(.created_at)
            | last
            | .body // empty
          ')

          if [[ -z "$DECISION_BODY" ]]; then
            REVIEWS_JSON=$(gh api repos/${{ github.repository }}/pulls/${PR_NUMBER}/reviews --paginate)
            REVIEW_STATE=$(printf '%s' "$REVIEWS_JSON" | jq -r --arg run_started_at "$RUN_STARTED_AT" --arg automation_login "$AUTOMATION_LOGIN" '
              [
                .[]
                | select(.user.login == $automation_login)
                | select(.submitted_at != null and .submitted_at >= $run_started_at)
              ]
              | sort_by(.submitted_at)
              | last
              | .state // empty
            ' | tr '[:upper:]' '[:lower:]')

            case "$REVIEW_STATE" in
              approved)
                echo "found=true" >> "$GITHUB_OUTPUT"
                echo "ready=true" >> "$GITHUB_OUTPUT"
                echo "‚úÖ Structured marker missing; falling back to review state APPROVED."
                exit 0
                ;;
              changes_requested|commented|dismissed)
                echo "found=true" >> "$GITHUB_OUTPUT"
                echo "ready=false" >> "$GITHUB_OUTPUT"
                echo "‚ÑπÔ∏è Structured marker missing; review state is ${REVIEW_STATE}."
                exit 0
                ;;
              *)
                echo "found=false" >> "$GITHUB_OUTPUT"
                echo "ready=false" >> "$GITHUB_OUTPUT"
                echo "::notice::No structured ready marker or qualifying review state found after ${RUN_STARTED_AT}."
                exit 0
                ;;
            esac
          fi

          READY_VALUE=$(printf '%s\n' "$DECISION_BODY" \
            | awk -F= '/^READY_FOR_REVIEW=/{print $2; exit}' \
            | tr '[:upper:]' '[:lower:]')

          case "$READY_VALUE" in
            true|false)
              echo "found=true" >> "$GITHUB_OUTPUT"
              echo "ready=$READY_VALUE" >> "$GITHUB_OUTPUT"
              echo "‚úÖ Parsed READY_FOR_REVIEW=$READY_VALUE"
              ;;
            *)
              echo "found=false" >> "$GITHUB_OUTPUT"
              echo "ready=false" >> "$GITHUB_OUTPUT"
              echo "::warning::Structured decision marker was present but invalid. Expected READY_FOR_REVIEW=true|false."
              ;;
          esac

      - name: Set reusable workflow outputs
        id: set-outputs
        if: always()
        shell: bash
        run: |
          set -euo pipefail

          READY="false"
          FOUND="false"
          PR_NUMBER=""
          HEAD_SHA=""

          if [[ "${{ steps.extract-pr.outputs.has_pr || 'false' }}" == "true" ]]; then
            PR_NUMBER="${{ steps.extract-pr.outputs.pr_number }}"
            HEAD_SHA="${{ steps.fetch-pr.outputs.head_sha }}"
          fi

          if [[ "${{ steps.parse-ready-decision.outputs.found || 'false' }}" == "true" ]]; then
            FOUND="true"
          fi

          if [[ "${{ steps.parse-ready-decision.outputs.ready || 'false' }}" == "true" ]]; then
            READY="true"
          fi

          echo "ready=${READY}" >> "$GITHUB_OUTPUT"
          echo "found=${FOUND}" >> "$GITHUB_OUTPUT"
          echo "pr_number=${PR_NUMBER}" >> "$GITHUB_OUTPUT"
          echo "head_sha=${HEAD_SHA}" >> "$GITHUB_OUTPUT"

          echo "‚úÖ Outputs prepared: ready=${READY}, found=${FOUND}, pr_number=${PR_NUMBER}, head_sha=${HEAD_SHA}"


  ready-automation:
    name: Draft‚ÜíReady + CI Trigger Automation
    needs: review
    if: ${{ needs.review.outputs.ready == 'true' && needs.review.outputs.found == 'true' }}
    runs-on: ubicloud-standard-2
    timeout-minutes: 15
    permissions:
      contents: write
      pull-requests: write
      actions: read
    env:
      GITHUB_TOKEN: ${{ secrets.CLAUDE_REVIEW_GH_TOKEN }}
      GH_TOKEN: ${{ secrets.CLAUDE_REVIEW_GH_TOKEN }}
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.CLAUDE_REVIEW_GH_TOKEN }}

      - name: Fetch PR metadata
        id: pr-meta
        shell: bash
        run: |
          set -euo pipefail

          PR_NUMBER="${{ needs.review.outputs.pr_number }}"
          INPUT_HEAD_SHA="${{ needs.review.outputs.head_sha }}"

          PR_JSON=$(gh api repos/${{ github.repository }}/pulls/${PR_NUMBER})

          IS_DRAFT=$(printf '%s' "$PR_JSON" | jq -r '.draft')
          HEAD_REF=$(printf '%s' "$PR_JSON" | jq -r '.head.ref')
          HEAD_REPO=$(printf '%s' "$PR_JSON" | jq -r '.head.repo.full_name')
          CURRENT_HEAD_SHA=$(printf '%s' "$PR_JSON" | jq -r '.head.sha')

          if [[ "$INPUT_HEAD_SHA" != "$CURRENT_HEAD_SHA" ]]; then
            echo "::notice::Input head_sha (${INPUT_HEAD_SHA}) differs from current PR head (${CURRENT_HEAD_SHA}); using current PR head SHA."
          fi

          echo "pr_number=${PR_NUMBER}" >> "$GITHUB_OUTPUT"
          echo "is_draft=${IS_DRAFT}" >> "$GITHUB_OUTPUT"
          echo "head_ref=${HEAD_REF}" >> "$GITHUB_OUTPUT"
          echo "head_repo=${HEAD_REPO}" >> "$GITHUB_OUTPUT"
          echo "head_sha=${CURRENT_HEAD_SHA}" >> "$GITHUB_OUTPUT"

      - name: Unresolved review-thread gate (paginate all pages)
        shell: bash
        run: |
          set -euo pipefail

          PR_NUMBER="${{ steps.pr-meta.outputs.pr_number }}"
          OWNER="${{ github.repository_owner }}"
          REPO="${GITHUB_REPOSITORY#*/}"

          QUERY='query($owner:String!, $repo:String!, $number:Int!, $after:String) {
            repository(owner:$owner, name:$repo) {
              pullRequest(number:$number) {
                reviewThreads(first:100, after:$after) {
                  nodes { isResolved }
                  pageInfo { hasNextPage endCursor }
                }
              }
            }
          }'

          AFTER=""
          PAGE=1
          TOTAL_THREADS=0
          UNRESOLVED_THREADS=0

          while true; do
            if [[ -n "$AFTER" ]]; then
              RESPONSE=$(gh api graphql                 -f query="$QUERY"                 -f owner="$OWNER"                 -f repo="$REPO"                 -F number="$PR_NUMBER"                 -f after="$AFTER")
            else
              RESPONSE=$(gh api graphql                 -f query="$QUERY"                 -f owner="$OWNER"                 -f repo="$REPO"                 -F number="$PR_NUMBER")
            fi

            if [[ "$(printf '%s' "$RESPONSE" | jq -r '.data.repository.pullRequest == null')" == "true" ]]; then
              echo "::error::Unable to load PR #${PR_NUMBER} review threads via GraphQL."
              exit 1
            fi

            PAGE_TOTAL=$(printf '%s' "$RESPONSE" | jq '.data.repository.pullRequest.reviewThreads.nodes | length')
            PAGE_UNRESOLVED=$(printf '%s' "$RESPONSE" | jq '[.data.repository.pullRequest.reviewThreads.nodes[] | select(.isResolved == false)] | length')

            TOTAL_THREADS=$((TOTAL_THREADS + PAGE_TOTAL))
            UNRESOLVED_THREADS=$((UNRESOLVED_THREADS + PAGE_UNRESOLVED))

            HAS_NEXT=$(printf '%s' "$RESPONSE" | jq -r '.data.repository.pullRequest.reviewThreads.pageInfo.hasNextPage')
            if [[ "$HAS_NEXT" != "true" ]]; then
              break
            fi

            AFTER=$(printf '%s' "$RESPONSE" | jq -r '.data.repository.pullRequest.reviewThreads.pageInfo.endCursor // empty')
            if [[ -z "$AFTER" ]]; then
              echo "::error::Pagination indicated hasNextPage=true but endCursor was empty (page ${PAGE})."
              exit 1
            fi

            PAGE=$((PAGE + 1))
          done

          echo "Checked ${TOTAL_THREADS} review threads across ${PAGE} page(s)."

          if [[ "$UNRESOLVED_THREADS" -gt 0 ]]; then
            echo "::error::READY_FOR_REVIEW=true but PR #${PR_NUMBER} still has ${UNRESOLVED_THREADS} unresolved review thread(s)."
            exit 1
          fi

          echo "‚úÖ No unresolved review threads remain."

      - name: Draft ‚Üí ready transition
        if: steps.pr-meta.outputs.is_draft == 'true'
        shell: bash
        run: |
          set -euo pipefail
          gh pr ready "${{ steps.pr-meta.outputs.pr_number }}" --repo "${{ github.repository }}"

      - name: Skip CI trigger commit for fork PRs
        if: steps.pr-meta.outputs.head_repo != github.repository
        shell: bash
        run: |
          set -euo pipefail
          echo "::notice::PR #${{ steps.pr-meta.outputs.pr_number }} head repo is ${{ steps.pr-meta.outputs.head_repo }}; skipping empty commit because branch is not local to target repo."

      - name: Evaluate check runs for trigger-commit eligibility
        id: checks
        if: steps.pr-meta.outputs.head_repo == github.repository
        shell: bash
        run: |
          set -euo pipefail

          HEAD_SHA="${{ steps.pr-meta.outputs.head_sha }}"

          CHECKS_JSON=$(gh api repos/${{ github.repository }}/commits/${HEAD_SHA}/check-runs)
          TOTAL_CHECKS=$(printf '%s' "$CHECKS_JSON" | jq -r '.total_count // 0')
          ACTION_REQUIRED_CHECKS=$(printf '%s' "$CHECKS_JSON" | jq -r '[.check_runs[]? | select(.conclusion == "action_required")] | length')

          SHOULD_TRIGGER="false"
          TRIGGER_REASON=""

          if [[ "$ACTION_REQUIRED_CHECKS" -gt 0 ]]; then
            SHOULD_TRIGGER="true"
            TRIGGER_REASON="action_required checks (${ACTION_REQUIRED_CHECKS}/${TOTAL_CHECKS})"
          elif [[ "$TOTAL_CHECKS" -eq 0 ]]; then
            SHOULD_TRIGGER="true"
            TRIGGER_REASON="no check-runs found on head SHA (likely missing ready_for_review trigger in caller workflows)"
          fi

          echo "total_checks=${TOTAL_CHECKS}" >> "$GITHUB_OUTPUT"
          echo "action_required_checks=${ACTION_REQUIRED_CHECKS}" >> "$GITHUB_OUTPUT"
          echo "should_trigger=${SHOULD_TRIGGER}" >> "$GITHUB_OUTPUT"
          echo "trigger_reason=${TRIGGER_REASON}" >> "$GITHUB_OUTPUT"

      - name: Skip trigger commit when checks are already healthy
        if: |
          steps.pr-meta.outputs.head_repo == github.repository &&
          steps.checks.outputs.should_trigger != 'true'
        shell: bash
        run: |
          set -euo pipefail
          echo "::notice::PR #${{ steps.pr-meta.outputs.pr_number }} has checks (${{ steps.checks.outputs.total_checks }}) and none are action_required. Skipping empty commit."

      - name: Prevent duplicate trigger commit
        id: duplicate-commit
        if: |
          steps.pr-meta.outputs.head_repo == github.repository &&
          steps.checks.outputs.should_trigger == 'true'
        shell: bash
        run: |
          set -euo pipefail

          PR_NUMBER="${{ steps.pr-meta.outputs.pr_number }}"

          TRIGGER_COMMIT_COUNT=$(gh api repos/${{ github.repository }}/pulls/${PR_NUMBER}/commits --paginate             | jq -rs '[.[] | .[] | .commit.message | split("\n")[0] | select(startswith("ci: trigger checks after"))] | length')

          if [[ "$TRIGGER_COMMIT_COUNT" -gt 0 ]]; then
            echo "already_triggered=true" >> "$GITHUB_OUTPUT"
          else
            echo "already_triggered=false" >> "$GITHUB_OUTPUT"
          fi

      - name: Skip duplicate trigger commit
        if: |
          steps.pr-meta.outputs.head_repo == github.repository &&
          steps.checks.outputs.should_trigger == 'true' &&
          steps.duplicate-commit.outputs.already_triggered == 'true'
        shell: bash
        run: |
          set -euo pipefail
          echo "::notice::PR #${{ steps.pr-meta.outputs.pr_number }} already has a CI trigger empty commit. Skipping additional empty commit."

      - name: Push empty commit to trigger CI checks
        if: |
          steps.pr-meta.outputs.head_repo == github.repository &&
          steps.checks.outputs.should_trigger == 'true' &&
          steps.duplicate-commit.outputs.already_triggered != 'true'
        shell: bash
        run: |
          set -euo pipefail

          HEAD_REF="${{ steps.pr-meta.outputs.head_ref }}"

          echo "‚ÑπÔ∏è PR #${{ steps.pr-meta.outputs.pr_number }}: ${{ steps.checks.outputs.trigger_reason }}. Pushing one empty commit to trigger CI."

          git config user.name "Claude PR Assistant"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"

          git fetch origin "$HEAD_REF"
          git switch -C "$HEAD_REF" "origin/$HEAD_REF"
          git commit --allow-empty -m "ci: trigger checks after claude ready decision"
          git push origin "HEAD:$HEAD_REF"
